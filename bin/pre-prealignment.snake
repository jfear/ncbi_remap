#/usr/bin/env python
# vim: set ft=python.snakemake
""" The prealignment workflow to identify basic characteristics about SRA runs.

Zhenxia originally developed this workflow. The goal here is to use the data to
determine if the sample is really RNA-seq and strandedness.

"""
import os
import signal
import re
from textwrap import dedent
import shutil as sh
from gzip import open as gopen

import numpy as np
import pandas as pd

from lcdblib.snakemake import helpers, aligners
from lcdblib.utils import utils

from pymongo import MongoClient

sys.path.insert(0, '../lib/python')
from ncbi_remap import mongo_schema as ms

# Setup tempdir to work with lscratch
TMPDIR = os.path.join('/lscratch', os.getenv('SLURM_JOBID'))
TMPDIR = '/mnt/threeTB/centos_scratch'
shell.prefix("set -euo pipefail; export TMPDIR={};".format(TMPDIR))

workdir: '.'

# Connect to mongodb
with open('.mongodb_host', 'r') as fh:
    mongo_client = MongoClient(host=fh.read().strip(), port=27022)
    db = mongo_client['sra2']
    remap = db['remap']

################################################################################
# Set up file naming patterns
################################################################################
patterns = {'fastq': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.fastq.precheck.done'}

# Import run_id and experiment_id and dump into a dataframe
samples = remap.aggregate([
    {'$match': {
        'srp': 'SRP072244',
        'runs.srr': {'$exists': 1},
        '$or': [
            {'runs.pre_aln_flags': {'$exists': 0}},
            {'runs.pre_aln_flags': {'$eq': []}},
            ]
        }
    },
    {'$unwind': '$runs'},
    {'$project': {'_id': 0, 'experiment': '$_id', 'sample': '$runs.srr'}}
])
sample_table = pd.DataFrame(list(samples))
sample_table.sort_values(by='sample', inplace=True)

#targets = helpers.fill_patterns(patterns, sample_table.iloc[0:10000,:])
targets = helpers.fill_patterns(patterns, sample_table)

rule targets:
    input: utils.flatten(targets)

################################################################################
# FASTQ dump and check for SE or PE
################################################################################
def check_fastq(fn):
    """Checks if a gzip file actually has data in it."""
    try:
        assert os.stat(fn).st_size > 10000
        return True
    except (FileNotFoundError, AssertionError) as err:
        return False
    except:
        raise

"""Downloads fastq and checks if there is one or two sets of reads."""
rule fastq_dump:
    output:
        fastq=temp(patterns['fastq'])
    run:
        shell("fastq-dump -O $TMPDIR --split-files --gzip {wildcards.sample}")

        fn1 = wildcards.sample + '_1.fastq.gz'
        fn2 = wildcards.sample + '_2.fastq.gz'
        if check_fastq(os.path.join(TMPDIR, fn2)):
            # Check read 2
            remap.find_one_and_update({'runs.srr': wildcards.sample}, {'$addToSet': {'runs.$.pre_aln_flags': 'PE'}})
        elif check_fastq(os.path.join(TMPDIR, fn1)):
            # Check read 1
            remap.find_one_and_update({'runs.srr': wildcards.sample}, {'$addToSet': {'runs.$.pre_aln_flags': 'SE'}})
        else:
            raise ValueError

        with open(output.fastq, 'w') as fh:
            fh.write()
