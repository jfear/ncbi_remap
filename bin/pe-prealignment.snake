#/usr/bin/env python

# vim: set ft=python.snakemake
""" The prealignment workflow to identify basic characteristics about SRA runs.

Zhenxia originally developed this workflow. The goal here is to use the data to
determine if the sample is really RNA-seq and strandedness.

"""
import os
import sys

import pandas as pd
from pymongo import MongoClient

from lcdblib.snakemake import helpers
from lcdblib.utils import utils
from lcdblib.pandas.utils import cartesian_product

# Setup tempdir to work with lscratch
TMPDIR = os.path.join('/lscratch', os.getenv('SLURM_JOBID'))
#TMPDIR = '/mnt/threeTB/centos_scratch'
shell.prefix("set -euo pipefail; export TMPDIR={};".format(TMPDIR))

# Set working dir
workdir: '.'

# import config
configfile: '../config/prealignment_config.yaml'

# Connect to mongodb
with open('.mongodb_host', 'r') as fh:
    mongo_client = MongoClient(host=fh.read().strip(), port=27022)
    db = mongo_client['sra']

# Find snakemake wrappers:
def wrapper_for(path):
    URI = '../lcdb-wrapper-tests'
    return 'file:' + os.path.join(URI, 'wrappers', path)

################################################################################
# Build Sample Table
################################################################################
with open('../data/test_samples', 'r') as fh:
    test_samples = [x.strip() for x in fh.readlines()]

sample_table = pd.DataFrame(list(db.run.find({'pipeline_flags': 'PE', '_id': {'$in': test_samples}}, {'_id': 1, 'experiment_id': 1})))
sample_table.rename(columns={'_id': 'sample', 'experiment_id': 'experiment'}, inplace=True)
sample_table.sort_values(by='sample', inplace=True)
#sample_table = sample_table.head(2).copy()

# Add strand info 1=forward, 2=reverse
sample_table = cartesian_product(sample_table, {'featurecount_strand': [1, 2]})
sample_table.loc[sample_table['featurecount_strand'] == 1, 'picard_collectrnaseqmetrics'] = 'FIRST_READ_TRANSCRIPTION_STRAND'
sample_table.loc[sample_table['featurecount_strand'] == 2, 'picard_collectrnaseqmetrics'] = 'SECOND_READ_TRANSCRIPTION_STRAND'

################################################################################
# Set up file naming patterns and targets
################################################################################
patterns = {
    'fastq_clean': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.clean.fastq.gz',
        'r2': '../output/prealignment/raw/{experiment}/{sample}/{sample}_2.clean.fastq.gz',
        },
    'fastq_md5': '../output/prealignment/raw/{experiment}/{sample}/{sample}.md5',
    'fastq_clean_count': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.clean.fastq.gz.libsize',
        'r2': '../output/prealignment/raw/{experiment}/{sample}/{sample}_2.clean.fastq.gz.libsize',
        },
    'atropos': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.trim.clean.fastq.gz',
        'r2': '../output/prealignment/raw/{experiment}/{sample}/{sample}_2.trim.clean.fastq.gz',
        },
    'fastq_atropos_count': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.trim.clean.fastq.gz.libsize',
        'r2': '../output/prealignment/raw/{experiment}/{sample}/{sample}_2.trim.clean.fastq.gz.libsize',
        },
    'fastq_screen': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.clean_screen.txt',
    'fastqc': {
        'html': '../output/prealignment/raw/{experiment}/{sample}/{sample}_fastqc.html',
        'zip': '../output/prealignment/raw/{experiment}/{sample}/{sample}_fastqc.zip',
        },
    'bed12': '../output/dm6_r6-11.bed12',
    'hisat2': {
        'splice_sites': '../output/known_splice_sites_r6-11.txt',
        'bam': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam',
        },
    'bai': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.bai',
    'rseqc': {
        'bam_stat': '../output/prealignment/raw/{experiment}/{sample}/{sample}.bam_stat.txt',
        'infer_experiment': '../output/prealignment/raw/{experiment}/{sample}/{sample}.infer_experiment.txt',
        'geneBodyCoverage': {
            'txt': '../output/prealignment/raw/{experiment}/{sample}/{sample}.geneBodyCoverage.txt',
            'r': '../output/prealignment/raw/{experiment}/{sample}/{sample}.geneBodyCoverage.r',
            'img': '../output/prealignment/raw/{experiment}/{sample}/{sample}.geneBodyCoverage.pdf',
        },
        'tin': {
            'table': '../output/prealignment/raw/{experiment}/{sample}/{sample}.tin.tsv',
            'summary': '../output/prealignment/raw/{experiment}/{sample}/{sample}.tin.txt',
        },
    },
    'dupradar': {
        'density_scatter': '../output/prealignment/raw/{experiment}/{sample}/{sample}.density_scatter.png',
        'expression_histogram': '../output/prealignment/raw/{experiment}/{sample}/{sample}.expression_histogram.png',
        'expression_boxplot': '../output/prealignment/raw/{experiment}/{sample}/{sample}.expression_boxplot.png',
        'expression_barplot': '../output/prealignment/raw/{experiment}/{sample}/{sample}.expression_barplot.png',
        'multimapping_histogram': '../output/prealignment/raw/{experiment}/{sample}/{sample}.multimapping_histogram.png',
        'dataframe': '../output/prealignment/raw/{experiment}/{sample}/{sample}.dupradar.tsv',
    },
    'feature_counts': {
        'counts': '../output/prealignment/raw/{experiment}/{sample}/{sample}_{featurecount_strand}.fq.bam.counts',
        'summary': '../output/prealignment/raw/{experiment}/{sample}/{sample}_{featurecount_strand}.fq.bam.counts.summary',
    },
    'picard': {
        'collectrnaseqmetrics': {
            'metrics': '../output/prealignment/raw/{experiment}/{sample}/{sample}_{picard_collectrnaseqmetrics}.fq.bam.picard.collectrnaseqmetrics',
        },
        'markduplicates': {
            'bam': '../output/prealignment/raw/{experiment}/{sample}/{sample}.picard.dups.fq.bam',
            'metrics': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.picard.markduplicatesmetrics',
        },
    },
    'samtools_stats': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.samtools.stats',
    'samtools_idxstats': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.samtools.idxstats',
    'bamtools_stats': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.bamtools.stats',
}

# Build target files
targets = helpers.fill_patterns(patterns, sample_table)
rule targets:
    input: utils.flatten(targets['fastq_atropos_count'])

#         utils.flatten(targets['fastqc']) +
#         utils.flatten(targets['fastq_clean_count']) +
#         utils.flatten(targets['fastq_atropos_count']) +
#         utils.flatten(targets['fastq_screen']) +
#         utils.flatten(targets['feature_counts']) +
#         utils.flatten(targets['picard']['collectrnaseqmetrics']['metrics']) +
#         utils.flatten(targets['picard']['markduplicates']['metrics']) +
#         utils.flatten(targets['rseqc']) +
#         utils.flatten(targets['dupradar']) +
#         utils.flatten(targets['samtools_stats']) +
#         utils.flatten(targets['bamtools_stats'])


################################################################################
# FASTQ Pre-process
################################################################################
rule fastq_clean:
    output:
        r1=temp(patterns['fastq_clean']['r1']),
        r2=temp(patterns['fastq_clean']['r2']),
        md5=patterns['fastq_md5'],
    shell:
        'fastq-dump -O $TMPDIR -X 1000000 --split-files --gzip {wildcards.sample} '
        '&& gunzip -c $TMPDIR/{wildcards.sample}_1.fastq.gz $TMPDIR/{wildcards.sample}_2.fastq.gz | md5sum > {output.md5}'
        '&& ./get_proper_read_pairs.sh $TMPDIR/{wildcards.sample}_1.fastq.gz $TMPDIR/{wildcards.sample}_2.fastq.gz $TMPDIR/{wildcards.sample}_1.clean.fastq.gz $TMPDIR/{wildcards.sample}_2.clean.fastq.gz '
        '&& cp $TMPDIR/{wildcards.sample}_1.clean.fastq.gz {output.r1} '
        '&& cp $TMPDIR/{wildcards.sample}_2.clean.fastq.gz {output.r2} '
        '&& rm $TMPDIR/{wildcards.sample}_1.fastq.gz $TMPDIR/{wildcards.sample}_2.fastq.gz '
        '&& rm $TMPDIR/{wildcards.sample}_1.clean.fastq.gz $TMPDIR/{wildcards.sample}_2.clean.fastq.gz '


rule atropos:
    input:
        R1=patterns['fastq_clean']['r1'],
        R2=patterns['fastq_clean']['r2']
    output:
        R1=temp(patterns['atropos']['r1']),
        R2=temp(patterns['atropos']['r2'])
    params:
        extra='-a file:../data/adapters.fa -A file:../data/adapters.fa -q 20'
    log: patterns['atropos']['r1'] + '.log'
    threads: 8
    wrapper: wrapper_for('atropos')


rule fastq_count:
    input: '{prefix}.fastq.gz'
    output: '{prefix}.fastq.gz.libsize'
    shell: 'zcat {input} | echo $((`wc -l`/4)) > {output}'

################################################################################
# FASTQ QC
################################################################################
rule fastqc:
    input: patterns['fastq_clean']['r1']
    output:
        html=patterns['fastqc']['html'],
        zip=patterns['fastqc']['zip']
    params: extra="--format fastq"
    log: patterns['fastqc']['html'] + '.log'
    wrapper: wrapper_for('fastqc')

rule fastq_screen:
    input:
        fastq=patterns['fastq_clean']['r1'],
        dm6=config['references']['dmel']['bowtie2'],
        hg19=config['references']['human']['bowtie2'],
        wolbachia=config['references']['wolbachia']['bowtie2'],
        ecoli=config['references']['ecoli']['bowtie2'],
        yeast=config['references']['yeast']['bowtie2'],
        rRNA=config['references']['rRNA']['bowtie2'],
        phix=config['references']['phix']['bowtie2'],
        ercc=config['references']['ercc']['bowtie2'],
        adapters=config['references']['adapters']['bowtie2']
    output: txt=patterns['fastq_screen']
    log: patterns['fastq_screen'] + '.log'
    wrapper: wrapper_for('fastq_screen')

################################################################################
# Alignment
################################################################################
rule hisat2_splice_site:
    input: gtf=config['references']['dmel']['gtf']
    output: patterns['hisat2']['splice_sites']
    shell: "hisat2_extract_splice_sites.py {input.gtf} > {output}"

rule hisat2_fastq:
    input:
        index=config['references']['dmel']['hisat2'],
        splice_sites=patterns['hisat2']['splice_sites'],
        fastq=[rules.fastq_clean.output.r1, rules.fastq_clean.output.r2],
    output: bam=temp(patterns['hisat2']['bam'])
    threads: 8
    params:
        hisat2_extra='--max-intronlen 300000 --known-splicesite-infile {input.splice_sites}',
        samtools_sort_extra='--threads 6 -l 9 -m 3G -T $TMPDIR/samtools_sort'
    log: patterns['hisat2']['bam'] + '.log'
    wrapper: wrapper_for('hisat2/align')

rule bai:
    input: bam='{prefix}.bam'
    output: bai=temp('{prefix}.bam.bai')
    conda: "../environment.yaml"
    shell: "samtools index {input.bam}"

################################################################################
# RSEQC
################################################################################
rule gtf2bed12:
    input: db=config['references']['dmel']['db']
    output: bed12=patterns['bed12']
    run:
        import gffutils
        db = gffutils.FeatureDB(input.db)
        with open(output.bed12, 'w') as fo:
            for t in db.features_of_type('transcript'):
                fo.write(db.bed12(t, name_field='transcript_id') + '\n')

rule infer_experiment:
    input:
        bam=patterns['hisat2']['bam'],
        bed=patterns['bed12']
    output: txt=patterns['rseqc']['infer_experiment']
    log: patterns['rseqc']['infer_experiment'] + '.log'
    wrapper: wrapper_for('rseqc/infer_experiment')

rule geneBody_coverage:
    input:
        bam=patterns['hisat2']['bam'],
        bai=patterns['bai'],
        bed=patterns['bed12']
    output:
        txt=patterns['rseqc']['geneBodyCoverage']['txt'],
        r=patterns['rseqc']['geneBodyCoverage']['r'],
        img=patterns['rseqc']['geneBodyCoverage']['img']
    log: patterns['rseqc']['geneBodyCoverage']['txt'] + '.log'
    wrapper: wrapper_for('rseqc/geneBody_coverage')

rule tin:
    input:
        bam=patterns['hisat2']['bam'],
        bai=patterns['bai'],
        bed=patterns['bed12']
    output:
        table=patterns['rseqc']['tin']['table'],
        summary=patterns['rseqc']['tin']['summary']
    log: os.path.abspath(patterns['rseqc']['tin']['table'] + '.log')
    wrapper: wrapper_for('rseqc/tin')

rule bam_stat:
    input: bam=patterns['hisat2']['bam'],
    output: txt=patterns['rseqc']['bam_stat']
    log: patterns['rseqc']['bam_stat'] + '.log'
    wrapper: wrapper_for('rseqc/bam_stat')

################################################################################
# DupRadar
################################################################################
rule dupRadar:
    input:
       bam=patterns['hisat2']['bam'],
       annotation=config['references']['dmel']['gtf'],
    output:
        density_scatter=patterns['dupradar']['density_scatter'],
        expression_histogram=patterns['dupradar']['expression_histogram'],
        expression_boxplot=patterns['dupradar']['expression_boxplot'],
        expression_barplot=patterns['dupradar']['expression_barplot'],
        multimapping_histogram=patterns['dupradar']['multimapping_histogram'],
        dataframe=patterns['dupradar']['dataframe']
    wrapper:
        wrapper_for('dupradar')

################################################################################
# Feature Counts
################################################################################
rule featurecounts:
    input:
        annotation=config['references']['dmel']['gtf'],
        bam=patterns['hisat2']['bam']
    output:
        counts=patterns['feature_counts']['counts'],
        summary=patterns['feature_counts']['summary']
    params: extra='-p -s {featurecount_strand}'
    wrapper: wrapper_for('featurecounts')

################################################################################
# Stats
################################################################################
rule run_stats:
    input:
        bam=patterns['hisat2']['bam'],
        bai=patterns['bai'],
    output:
        samtools_stats=patterns['samtools_stats'],
        samtools_idxstats=patterns['samtools_idxstats'],
        bamtools_stats=patterns['bamtools_stats']
    conda: '../environment.yaml'
    shell:
        'BAM=$(mktemp --suffix=".bam") '
        '&& cp {input.bam} $BAM '
        '&& cp {input.bam}.bai $BAM.bai '
        '&& samtools stats $BAM > {output.samtools_stats} '
        '&& samtools idxstats $BAM > {output.samtools_idxstats} '
        '&& bamtools stats -in $BAM > {output.bamtools_stats} '
        '&& rm $BAM'

################################################################################
# PICARD RNA Seq Metrics
################################################################################
rule collectrnaseqmetrics:
    input:
        bam=patterns['hisat2']['bam'],
        refflat=config['references']['dmel']['refflat']
    output: metrics=patterns['picard']['collectrnaseqmetrics']['metrics']
    params: extra='STRAND={picard_collectrnaseqmetrics}'
    log: patterns['picard']['collectrnaseqmetrics']['metrics'] + '.log'
    wrapper: wrapper_for('picard/collectrnaseqmetrics')

rule markduplicates:
    input: bam=patterns['hisat2']['bam']
    output:
        bam=temp(patterns['picard']['markduplicates']['bam']),
        metrics=patterns['picard']['markduplicates']['metrics']
    log: patterns['picard']['markduplicates']['metrics'] + '.log'
    wrapper: wrapper_for('picard/markduplicates')
