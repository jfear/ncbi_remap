#/usr/bin/env python
# vim: set ft=python.snakemake
""" The prealignment workflow to identify basic characteristics about SRA runs.

Zhenxia originally developed this workflow. The goal here is to use the data to
determine if the sample is really RNA-seq and strandedness.

"""
import os
import sys

import pandas as pd

from lcdblib.snakemake import helpers
from lcdblib.utils import utils
from lcdblib.pandas.utils import cartesian_product

# import common header element
include: 'header.snake'
from ncbi_remap import mongo_schema as ms

# import config
configfile: '../config/prealignment_config.yaml'

################################################################################
# Build Sample Table
################################################################################
with open('../data/test_samples', 'r') as fh:
    test_samples = [x.strip() for x in fh.readlines()]

sample_table = pd.DataFrame(list(ms.Run._get_collection().find({'pipeline_flags': 'SE', '_id': {'$in': test_samples}}, {'_id': 1, 'experiment_id': 1})))
sample_table.rename(columns={'_id': 'sample', 'experiment_id': 'experiment'}, inplace=True)
sample_table.sort_values(by='sample', inplace=True)
sample_table = sample_table.head(1).copy()

# Add strand info 1=forward, 2=reverse
sample_table = cartesian_product(sample_table, {'featurecount_strand': [1, 2]})
sample_table.loc[sample_table['featurecount_strand'] == 1, 'picard_collectrnaseqmetrics'] = 'FIRST_READ_TRANSCRIPTION_STRAND'
sample_table.loc[sample_table['featurecount_strand'] == 2, 'picard_collectrnaseqmetrics'] = 'SECOND_READ_TRANSCRIPTION_STRAND'

################################################################################
# Set up file naming patterns and targets
################################################################################
patterns = {
    'fastq_clean': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.clean.fastq.gz',
        },
    'fastq_clean_count': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.clean.fastq.gz.libsize',
        },
    'cutadapt': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.trim.clean.fastq.gz',
        },
    'fastq_cutadapt_count': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.trim.clean.fastq.gz.libsize',
        },
    'fastq_screen': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.clean_screen.txt',
    'fastqc': {
        'html': '../output/prealignment/raw/{experiment}/{sample}/{sample}_fastqc.html',
        'zip': '../output/prealignment/raw/{experiment}/{sample}/{sample}_fastqc.zip',
        },
    'bed12': '../output/dm6_r6-11.bed12',
    'hisat2': {
        'splice_sites':     '../output/known_splice_sites_r6-11.txt',
        'bam': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam',
        },
    'bai': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.bai',
    'rseqc': {
        'bam_stat': '../output/prealignment/raw/{experiment}/{sample}/{sample}.bam_stat.txt',
        'infer_experiment': '../output/prealignment/raw/{experiment}/{sample}/{sample}.infer_experiment.txt',
        'geneBodyCoverage': {
            'txt': '../output/prealignment/raw/{experiment}/{sample}/{sample}.geneBodyCoverage.txt',
            'r': '../output/prealignment/raw/{experiment}/{sample}/{sample}.geneBodyCoverage.r',
            'img': '../output/prealignment/raw/{experiment}/{sample}/{sample}.geneBodyCoverage.pdf',
        },
        'tin': {
            'table': '../output/prealignment/raw/{experiment}/{sample}/{sample}.tin.tsv',
            'summary': '../output/prealignment/raw/{experiment}/{sample}/{sample}.tin.txt',
        },
    },
    'feature_counts': {
        'counts': '../output/prealignment/raw/{experiment}/{sample}/{sample}_{featurecount_strand}.fq.bam.counts',
        'summary': '../output/prealignment/raw/{experiment}/{sample}/{sample}_{featurecount_strand}.fq.bam.counts.summary',
    },
    'picard_collectrnaseqmetrics': {
        'metrics': '../output/prealignment/raw/{experiment}/{sample}/{sample}_{picard_collectrnaseqmetrics}.fq.bam.picard.metrics',
    },
}

# Build target files
targets = helpers.fill_patterns(patterns, sample_table)

rule targets:
    input:
        utils.flatten(targets['fastq_count']) +
        utils.flatten(targets['fastq_clean_count']) +
        utils.flatten(targets['fastq_cutadapt_count']) +
        utils.flatten(targets['fastq_screen']) +
        utils.flatten(targets['fastqc']) +
        utils.flatten(targets['rseqc']) +
        utils.flatten(targets['feature_counts']) +
        utils.flatten(targets['picard_collectrnaseqmetrics'])

################################################################################
# FASTQ Pre-process
################################################################################
rule fastq_clean:
    output:
        r1=patterns['fastq_clean']['r1']
    shell:
        'fastq-dump -O $TMPDIR --split-files --gzip {wildcards.sample} '
        '&& cp $TMPDIR/*_1.fastq.gz {output.r1}'

rule cutadapt:
    input:
        R1=patterns['fastq_clean']['r1'],
    output:
        R1=temp(patterns['cutadapt']['r1']),
    params:
        extra='-a file:../data/adapters.fa -q 20'
    log: patterns['cutadapt']['r1'] + '.log'
    wrapper:
        wrapper_for('cutadapt')

rule fastq_count:
    input: '{prefix}.fastq.gz'
    output: '{prefix}.fastq.gz.libsize'
    shell:
        'zcat {input} | echo $((`wc -l`/4)) > {output}'

################################################################################
# FASTQ QC
################################################################################
rule fastqc:
    input: patterns['fastq_clean']['r1']
    output:
        html=patterns['fastqc']['html'],
        zip=patterns['fastqc']['zip']
    params: extra="--format fastq"
    log: patterns['fastqc']['html'] + '.log'
    wrapper:
        wrapper_for('fastqc')

rule fastq_screen:
    input:
        fastq=patterns['fastq_clean']['r1'],
        dm6=config['references']['dmel']['bowtie2'],
        hg19=config['references']['human']['bowtie2'],
        wolbachia=config['references']['wolbachia']['bowtie2'],
        ecoli=config['references']['ecoli']['bowtie2'],
        yeast=config['references']['yeast']['bowtie2'],
        rRNA=config['references']['rRNA']['bowtie2'],
        phix=config['references']['phix']['bowtie2'],
        ercc=config['references']['ercc']['bowtie2'],
        adapters=config['references']['adapters']['bowtie2']
    output:
        txt=patterns['fastq_screen']
    log: patterns['fastq_screen'] + '.log'
    wrapper:
        wrapper_for('fastq_screen')

################################################################################
# Alignment
################################################################################
rule hisat2_splice_site:
    input:
        gtf = config['references']['dmel']['gtf']
    output:
        patterns['hisat2']['splice_sites']
    shell:
        "hisat2_extract_splice_sites.py {input.gtf} > {output}"

rule hisat2_fastq:
    input:
        index=config['references']['dmel']['hisat2'],
        splice_sites=patterns['hisat2']['splice_sites'],
        fastq=patterns['fastq_clean']['r1']
    output:
        bam=temp(patterns['hisat2']['bam'])
    threads: 8
    params:
        hisat2_extra = '--max-intronlen 300000 --known-splicesite-infile {input.splice_sites}',
        samtools_sort_extra = '--threads 6 -l 9 -m 3G -T $TMPDIR/samtools_sort'
    log:
        patterns['hisat2']['bam'] + '.log'
    wrapper:
        wrapper_for('hisat2/align')

# rule hisat2_acc:
#     input:
#         index=patterns['hisat2']['index'],
#         splice_sites=patterns['hisat2']['splice_sites']
#     output:
#         bam = patterns['hisat2']['bam_acc']
#     threads: 8
#     params:
#         hisat2_extra = '--sra-acc SRR2069724 --max-intronlen 300000 --known-splicesite-infile {input.splice_sites}',
#         samtools_view_extra = '-q 20',
#         samtools_sort_extra = '--threads 6 -l 9 -m 3G -T $TMPDIR/samtools_sort'
#     log:
#         patterns['hisat2']['bam_acc'] + '.log'
#     wrapper:
#         wrapper_for('hisat2/align')

rule bai:
    input:
        bam='{prefix}.bam'
    output:
        bai=temp('{prefix}.bam.bai')
    shell:
        "samtools index {input.bam}"

################################################################################
# RSEQC
################################################################################
rule gtf2bed12:
    input:
        db = config['references']['dmel']['db']
    output:
        bed12 = patterns['bed12']
    run:
        import gffutils
        db = gffutils.FeatureDB(input.db)

        with open(output.bed12, 'w') as fo:
            for t in db.features_of_type('transcript'):
                fo.write(db.bed12(t, name_field='transcript_id') + '\n')

rule infer_experiment:
    input:
        bam = patterns['hisat2']['bam'],
        bed = patterns['bed12']
    output:
        txt = patterns['rseqc']['infer_experiment']
    log: patterns['rseqc']['infer_experiment'] + '.log'
    wrapper:
        wrapper_for('rseqc/infer_experiment')

rule geneBody_coverage:
    input:
        bam = patterns['hisat2']['bam'],
        bai = patterns['bai'],
        bed = patterns['bed12']
    output:
        txt = patterns['rseqc']['geneBodyCoverage']['txt'],
        r = patterns['rseqc']['geneBodyCoverage']['r'],
        img = patterns['rseqc']['geneBodyCoverage']['img']
    log: patterns['rseqc']['geneBodyCoverage']['txt'] + '.log'
    wrapper:
        wrapper_for('rseqc/geneBody_coverage')

rule tin:
    input:
        bam = patterns['hisat2']['bam'],
        bai = patterns['bai'],
        bed = patterns['bed12']
    output:
        table = patterns['rseqc']['tin']['table'],
        summary = patterns['rseqc']['tin']['summary']
    log: os.path.abspath(patterns['rseqc']['tin']['table'] + '.log')
    wrapper:
        wrapper_for('rseqc/tin')

rule bam_stat:
    input:
        bam = patterns['hisat2']['bam'],
    output:
        txt = patterns['rseqc']['bam_stat']
    log: patterns['rseqc']['bam_stat'] + '.log'
    wrapper:
        wrapper_for('rseqc/bam_stat')

################################################################################
# Feature Counts
################################################################################
rule featurecounts:
    input:
        annotation=config['references']['dmel']['gtf'],
        bam=patterns['hisat2']['bam']
    output:
        counts=patterns['feature_counts']['counts'],
        summary=patterns['feature_counts']['summary']
    params:
        extra='-s {featurecount_strand}'
    wrapper:
        wrapper_for('featurecounts')

################################################################################
# PICARD RNA Seq Metrics
################################################################################
rule collectrnaseqmetrics:
    input:
        bam=patterns['hisat2']['bam'],
        refflat=config['references']['dmel']['refflat']
    output:
        metrics=patterns['picard_collectrnaseqmetrics']['metrics']
    params:
        extra='STRAND={picard_collectrnaseqmetrics}'
    log: patterns['picard_collectrnaseqmetrics']['metrics'] + '.log'
    wrapper:
        wrapper_for('picard/collectrnaseqmetrics')
