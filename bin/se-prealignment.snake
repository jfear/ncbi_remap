#/usr/bin/env python
# vim: set ft=python.snakemake
import os
import sys

import pandas as pd
from pymongo import MongoClient
from pathlib import Path

from lcdblib.snakemake import helpers
from lcdblib.utils import utils

sys.path.insert(0, '../lib/python')
import ncbi_remap

# Setup tempdir to work with lscratch
TMPDIR = os.path.join('/lscratch', os.getenv('SLURM_JOBID'))
shell.prefix("set -euo pipefail; export TMPDIR={};".format(TMPDIR))

# Set working dir
workdir: '../.se-prealignment'

# import config
configfile: '../config/prealignment_config.yaml'

# Connect to mongodb
with open('../output/.mongodb_host', 'r') as fh:
    mongo_client = MongoClient(host=fh.read().strip(), port=27022)
    db = mongo_client['sra2']
    remap = db['remap']

# Find snakemake wrappers:
def wrapper_for(path):
    URI = '../lcdb-wf/wrappers/wrappers'
    return 'file:' + os.path.join(URI, path)

################################################################################
# Build Sample Table
################################################################################
samples = remap.aggregate([
    {'$unwind': '$runs'},
    {
        '$match': {
            '$and': [
                {'runs.srr': {'$exists': 1}},
                {'runs.pre_aln_flags': {'$ne': 'complete'}},
                {'runs.pre_aln_flags': 'SE'}
            ]
        }
    },
    {'$group': {'_id': {'sample': '$runs.srr', 'experiment': '$_id'}}},
    {'$project': {'_id': 0, 'experiment': '$_id.experiment', 'sample': '$_id.sample'}},
    {'$sort': {'sample': 1}},
])

sample_table = pd.DataFrame(list(samples))

################################################################################
# Set up file naming patterns and targets
################################################################################
# Build target files
all_complete = {'files': '../output/prealignment/raw/{experiment}/{sample}/{sample}.done'}
targets = helpers.fill_patterns(all_complete, sample_table)

# Patterns
fastqs = {
        'r1': '../output/pre-prealignment/raw/{experiment}/{sample}/{sample}_1.fastq.gz'
    }

patterns = {
    'fastq_screen': {
        'r1': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.clean_screen.txt',
    },
    'fastqc': {
        'r1': {
            'html': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1_fastqc.html',
            'zip': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1_fastqc.zip',
        },
    },
    'bed12': '../output/dm6_r6-11.bed12',
    'hisat2': {
        'splice_sites': '../output/known_splice_sites_r6-11.txt',
        'bam': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam',
    },
    'bai': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.bai',
    'rseqc': {
        'bam_stat': '../output/prealignment/raw/{experiment}/{sample}/{sample}.bam_stat.txt',
        'infer_experiment': '../output/prealignment/raw/{experiment}/{sample}/{sample}.infer_experiment.txt',
    },
    'dupradar': {
        'density_scatter': '../output/prealignment/raw/{experiment}/{sample}/{sample}.density_scatter.png',
        'expression_histogram': '../output/prealignment/raw/{experiment}/{sample}/{sample}.expression_histogram.png',
        'expression_boxplot': '../output/prealignment/raw/{experiment}/{sample}/{sample}.expression_boxplot.png',
        'expression_barplot': '../output/prealignment/raw/{experiment}/{sample}/{sample}.expression_barplot.png',
        'multimapping_histogram': '../output/prealignment/raw/{experiment}/{sample}/{sample}.multimapping_histogram.png',
        'dataframe': '../output/prealignment/raw/{experiment}/{sample}/{sample}.dupradar.tsv',
    },
    'feature_counts': {
        'first': {
            'counts': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.fq.bam.counts',
            'summary': '../output/prealignment/raw/{experiment}/{sample}/{sample}_1.fq.bam.counts.summary',
        },
        'second': {
            'counts': '../output/prealignment/raw/{experiment}/{sample}/{sample}_2.fq.bam.counts',
            'summary': '../output/prealignment/raw/{experiment}/{sample}/{sample}_2.fq.bam.counts.summary',
        },
    },
    'picard': {
        'collectrnaseqmetrics': {
            'metrics': {
                'first': '../output/prealignment/raw/{experiment}/{sample}/{sample}_FIRST_READ_TRANSCRIPTION_STRAND.fq.bam.picard.collectrnaseqmetrics',
                'second': '../output/prealignment/raw/{experiment}/{sample}/{sample}_SECOND_READ_TRANSCRIPTION_STRAND.fq.bam.picard.collectrnaseqmetrics',
            },
        },
        'markduplicates': {
            'bam': '../output/prealignment/raw/{experiment}/{sample}/{sample}.picard.dups.fq.bam',
            'metrics': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.picard.markduplicatesmetrics',
        },
    },
    'samtools_stats': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.samtools.stats',
    'samtools_idxstats': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.samtools.idxstats',
    'bamtools_stats': '../output/prealignment/raw/{experiment}/{sample}/{sample}.fq.bam.bamtools.stats',
}

localrules: check_results


rule targets:
    input: utils.flatten(targets)


rule check_results:
    input: utils.flatten(patterns)
    output: all_complete['files']
    run:
        remap.find_one_and_update(
                {'runs.srr': wildcards.sample},
                {'$addToSet': {'runs.$.pre_aln_flags': 'complete'}}
                )
        Path(output[0]).touch()


################################################################################
# FASTQ QC
################################################################################
rule fastqc:
    input: fastqs['r1']
    output:
        html=patterns['fastqc']['r1']['html'],
        zip=patterns['fastqc']['r1']['zip']
    params: extra="--format fastq"
    log: patterns['fastqc']['r1']['html'] + '.log'
    wrapper: wrapper_for('fastqc')


rule fastq_screen:
    input:
        fastq=fastqs['r1'],
        dm6=config['references']['dmel']['bowtie2'],
        hg19=config['references']['human']['bowtie2'],
        wolbachia=config['references']['wolbachia']['bowtie2'],
        ecoli=config['references']['ecoli']['bowtie2'],
        yeast=config['references']['yeast']['bowtie2'],
        rRNA=config['references']['rRNA']['bowtie2'],
        phix=config['references']['phix']['bowtie2'],
        ercc=config['references']['ercc']['bowtie2'],
        adapters=config['references']['adapters']['bowtie2']
    output: txt=patterns['fastq_screen']['r1']
    log: patterns['fastq_screen']['r1'] + '.log'
    wrapper: wrapper_for('fastq_screen')

################################################################################
# Alignment
################################################################################
rule hisat2_splice_site:
    input: gtf=config['references']['dmel']['gtf']
    output: patterns['hisat2']['splice_sites']
    shell: "hisat2_extract_splice_sites.py {input.gtf} > {output}"


rule hisat2_fastq:
    input:
        index=config['references']['dmel']['hisat2'],
        splice_sites=patterns['hisat2']['splice_sites'],
        fastq=fastqs['r1']
    output: bam=temp(patterns['hisat2']['bam'])
    threads: 8
    params:
        hisat2_extra='--max-intronlen 300000 --known-splicesite-infile {input.splice_sites}',
        samtools_sort_extra='--threads 6 -l 9 -m 3G -T $TMPDIR/samtools_sort'
    log: patterns['hisat2']['bam'] + '.log'
    wrapper: wrapper_for('hisat2/align')


rule bai:
    input: bam='{prefix}.bam'
    output: bai=temp('{prefix}.bam.bai')
    conda: "../config/samtools_environment.yaml"
    shell: "samtools index {input.bam}"


################################################################################
# RSEQC
################################################################################
rule gtf2bed12:
    input: db=config['references']['dmel']['db']
    output: bed12=patterns['bed12']
    run:
        import gffutils
        db = gffutils.FeatureDB(input.db)
        with open(output.bed12, 'w') as fo:
            for t in db.features_of_type('transcript'):
                fo.write(db.bed12(t, name_field='transcript_id') + '\n')


rule infer_experiment:
    input:
        bam=patterns['hisat2']['bam'],
        bed=patterns['bed12']
    output: txt=patterns['rseqc']['infer_experiment']
    log: patterns['rseqc']['infer_experiment'] + '.log'
    wrapper: wrapper_for('rseqc/infer_experiment')


rule bam_stat:
    input: bam=patterns['hisat2']['bam'],
    output: txt=patterns['rseqc']['bam_stat']
    log: patterns['rseqc']['bam_stat'] + '.log'
    wrapper: wrapper_for('rseqc/bam_stat')


################################################################################
# DupRadar
################################################################################
rule dupRadar:
    input:
       bam=patterns['hisat2']['bam'],
       annotation=config['references']['dmel']['gtf'],
    output:
        density_scatter=patterns['dupradar']['density_scatter'],
        expression_histogram=patterns['dupradar']['expression_histogram'],
        expression_boxplot=patterns['dupradar']['expression_boxplot'],
        expression_barplot=patterns['dupradar']['expression_barplot'],
        multimapping_histogram=patterns['dupradar']['multimapping_histogram'],
        dataframe=patterns['dupradar']['dataframe']
    wrapper:
        wrapper_for('dupradar')


################################################################################
# Feature Counts
################################################################################
rule featurecounts_first:
    input:
        annotation=config['references']['dmel']['gtf'],
        bam=patterns['hisat2']['bam']
    output:
        counts=patterns['feature_counts']['first']['counts'],
        summary=patterns['feature_counts']['first']['summary']
    params: extra='-s 1'
    wrapper: wrapper_for('featurecounts')


rule featurecounts_second:
    input:
        annotation=config['references']['dmel']['gtf'],
        bam=patterns['hisat2']['bam']
    output:
        counts=patterns['feature_counts']['second']['counts'],
        summary=patterns['feature_counts']['second']['summary']
    params: extra='-s 2'
    wrapper: wrapper_for('featurecounts')


################################################################################
# Stats
################################################################################
rule run_stats:
    input:
        bam=patterns['hisat2']['bam'],
        bai=patterns['bai'],
    output:
        samtools_stats=patterns['samtools_stats'],
        samtools_idxstats=patterns['samtools_idxstats'],
        bamtools_stats=patterns['bamtools_stats']
    conda: '../config/samtools_environment.yaml'
    shell:
        'BAM=$(mktemp --suffix=".bam") '
        '&& cp {input.bam} $BAM '
        '&& cp {input.bam}.bai $BAM.bai '
        '&& samtools stats $BAM > {output.samtools_stats} '
        '&& samtools idxstats $BAM > {output.samtools_idxstats} '
        '&& bamtools stats -in $BAM > {output.bamtools_stats} '
        '&& rm $BAM'


################################################################################
# PICARD RNA Seq Metrics
################################################################################
rule collectrnaseqmetrics_first:
    input:
        bam=patterns['hisat2']['bam'],
        refflat=config['references']['dmel']['refflat']
    output: metrics=patterns['picard']['collectrnaseqmetrics']['metrics']['first']
    params: extra='STRAND=FIRST_READ_TRANSCRIPTION_STRAND'
    log: patterns['picard']['collectrnaseqmetrics']['metrics']['first'] + '.log'
    wrapper: wrapper_for('picard/collectrnaseqmetrics')


rule collectrnaseqmetrics_second:
    input:
        bam=patterns['hisat2']['bam'],
        refflat=config['references']['dmel']['refflat']
    output: metrics=patterns['picard']['collectrnaseqmetrics']['metrics']['second']
    params: extra='STRAND=SECOND_READ_TRANSCRIPTION_STRAND'
    log: patterns['picard']['collectrnaseqmetrics']['metrics']['second'] + '.log'
    wrapper: wrapper_for('picard/collectrnaseqmetrics')


rule markduplicates:
    input: bam=patterns['hisat2']['bam']
    output:
        bam=temp(patterns['picard']['markduplicates']['bam']),
        metrics=patterns['picard']['markduplicates']['metrics']
    log: patterns['picard']['markduplicates']['metrics'] + '.log'
    wrapper: wrapper_for('picard/markduplicates')
